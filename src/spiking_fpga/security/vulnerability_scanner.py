"""Vulnerability scanner for HDL output and system security."""

import re
import subprocess
import os
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
import logging
import hashlib
import json

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Comprehensive vulnerability scanner for generated HDL and system."""
    
    def __init__(self):
        self.hdl_patterns = self._load_hdl_vulnerability_patterns()
        self.system_checks = self._load_system_security_checks()
        
    def _load_hdl_vulnerability_patterns(self) -> Dict[str, List[str]]:
        """Load HDL-specific vulnerability patterns."""
        return {
            'timing_attacks': [
                r'always\s*@\s*\(\s*\*\s*\)',  # Combinational always blocks
                r'assign.*=.*&.*\|',  # Complex combinational logic
                r'case\s*\([^)]*\).*default\s*:',  # Missing default cases
            ],
            'side_channel': [
                r'if\s*\([^)]*secret[^)]*\)',  # Conditional on secrets
                r'for\s*\([^)]*password[^)]*\)',  # Loops on sensitive data
                r'while\s*\([^)]*key[^)]*\)',  # While loops on keys
            ],
            'resource_exhaustion': [
                r'generate\s+for.*without.*limit',  # Unbounded generates
                r'always.*#\d+',  # Fixed delays (potential DoS)
                r'reg\s+\[\d{4,}:0\]',  # Very large registers
            ],
            'injection_vectors': [
                r'\\$[a-zA-Z_]+\\',  # System task calls
                r'initial.*\\$display',  # Debug outputs in production
                r'\\$readmem',  # Memory loading (potential injection)
            ],
            'crypto_weaknesses': [
                r'lfsr.*8\'h',  # Weak LFSR seeds
                r'random.*constant',  # Non-random "random" values
                r'xor.*0+',  # XOR with zeros
            ]
        }
    
    def _load_system_security_checks(self) -> List[str]:
        """Load system-level security checks."""
        return [
            'check_file_permissions',
            'check_process_isolation', 
            'check_network_exposure',
            'check_temporary_files',
            'check_environment_variables',
            'check_dependency_integrity'
        ]
    
    def scan_hdl_file(self, file_path: Path) -> Dict[str, Any]:
        """Scan HDL file for vulnerabilities."""
        vulnerabilities = {
            'file': str(file_path),
            'issues': [],
            'risk_level': 'LOW',
            'recommendations': []
        }
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
        except Exception as e:
            vulnerabilities['issues'].append({
                'type': 'file_access_error',
                'severity': 'HIGH',
                'message': f"Cannot read file: {e}"
            })
            return vulnerabilities
        
        # Check each vulnerability category
        for category, patterns in self.hdl_patterns.items():
            for pattern in patterns:
                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                for match in matches:
                    line_num = content[:match.start()].count('\n') + 1
                    
                    issue = {
                        'type': category,
                        'severity': self._get_severity(category),
                        'line': line_num,
                        'pattern': pattern,
                        'match': match.group(0),
                        'message': self._get_vulnerability_message(category)
                    }
                    vulnerabilities['issues'].append(issue)
        
        # Calculate overall risk level
        vulnerabilities['risk_level'] = self._calculate_risk_level(vulnerabilities['issues'])
        
        # Generate recommendations
        vulnerabilities['recommendations'] = self._generate_recommendations(
            vulnerabilities['issues'])
        
        return vulnerabilities
    
    def scan_hdl_directory(self, dir_path: Path) -> Dict[str, Any]:
        """Scan all HDL files in directory."""
        results = {
            'directory': str(dir_path),
            'files_scanned': 0,
            'total_issues': 0,
            'file_results': [],
            'summary': {}
        }
        
        hdl_extensions = {'.v', '.vhd', '.sv', '.vh'}
        
        for file_path in dir_path.rglob('*'):
            if file_path.suffix in hdl_extensions and file_path.is_file():
                file_result = self.scan_hdl_file(file_path)
                results['file_results'].append(file_result)
                results['files_scanned'] += 1
                results['total_issues'] += len(file_result['issues'])
        
        # Generate summary
        results['summary'] = self._generate_scan_summary(results['file_results'])
        
        return results
    
    def check_file_permissions(self, dir_path: Path) -> List[Dict[str, Any]]:
        """Check file permissions for security issues."""
        issues = []
        
        for file_path in dir_path.rglob('*'):
            if file_path.is_file():
                try:
                    stat = file_path.stat()
                    mode = stat.st_mode
                    
                    # Check for world-writable files
                    if mode & 0o002:
                        issues.append({
                            'type': 'world_writable',
                            'severity': 'HIGH',
                            'file': str(file_path),
                            'permissions': oct(mode),
                            'message': 'File is world-writable'
                        })
                    
                    # Check for world-readable sensitive files
                    if file_path.suffix in {'.key', '.pem', '.p12'} and mode & 0o004:
                        issues.append({
                            'type': 'world_readable_sensitive',
                            'severity': 'MEDIUM',
                            'file': str(file_path),
                            'permissions': oct(mode),
                            'message': 'Sensitive file is world-readable'
                        })
                    
                    # Check for executable HDL files (suspicious)
                    if file_path.suffix in {'.v', '.vhd', '.sv'} and mode & 0o111:
                        issues.append({
                            'type': 'executable_hdl',
                            'severity': 'MEDIUM',
                            'file': str(file_path),
                            'permissions': oct(mode),
                            'message': 'HDL file should not be executable'
                        })
                        
                except Exception as e:
                    issues.append({
                        'type': 'permission_check_error',
                        'severity': 'LOW',
                        'file': str(file_path),
                        'message': f"Cannot check permissions: {e}"
                    })
        
        return issues
    
    def check_process_isolation(self) -> List[Dict[str, Any]]:
        """Check for process isolation issues."""
        issues = []
        
        try:
            # Check for running processes that might interfere
            result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
            
            suspicious_processes = ['telnetd', 'rshd', 'rexecd', 'ftpd']
            for process in suspicious_processes:
                if process in result.stdout:
                    issues.append({
                        'type': 'suspicious_service',
                        'severity': 'HIGH',
                        'process': process,
                        'message': f'Potentially insecure service running: {process}'
                    })
        
        except Exception as e:
            issues.append({
                'type': 'process_check_error',
                'severity': 'LOW',
                'message': f"Cannot check processes: {e}"
            })
        
        return issues
    
    def check_network_exposure(self) -> List[Dict[str, Any]]:
        """Check for network security issues."""
        issues = []
        
        try:
            # Check for open ports
            result = subprocess.run(['netstat', '-tuln'], capture_output=True, text=True)
            
            # Look for potentially dangerous open ports
            dangerous_ports = ['23', '21', '79', '513', '514', '515']
            for port in dangerous_ports:
                if f':{port} ' in result.stdout:
                    issues.append({
                        'type': 'dangerous_open_port',
                        'severity': 'HIGH',
                        'port': port,
                        'message': f'Potentially insecure service on port {port}'
                    })
        
        except Exception as e:
            issues.append({
                'type': 'network_check_error',
                'severity': 'LOW',
                'message': f"Cannot check network: {e}"
            })
        
        return issues
    
    def check_temporary_files(self) -> List[Dict[str, Any]]:
        """Check for insecure temporary files."""
        issues = []
        
        temp_dirs = ['/tmp', '/var/tmp', '/dev/shm']
        
        for temp_dir in temp_dirs:
            temp_path = Path(temp_dir)
            if temp_path.exists():
                try:
                    # Look for spiking-fpga related temp files
                    for file_path in temp_path.glob('*spiking*'):
                        if file_path.is_file():
                            stat = file_path.stat()
                            
                            # Check permissions
                            if stat.st_mode & 0o077:  # Others can read/write
                                issues.append({
                                    'type': 'insecure_temp_file',
                                    'severity': 'MEDIUM',
                                    'file': str(file_path),
                                    'permissions': oct(stat.st_mode),
                                    'message': 'Temporary file has insecure permissions'
                                })
                
                except Exception as e:
                    issues.append({
                        'type': 'temp_check_error',
                        'severity': 'LOW',
                        'directory': temp_dir,
                        'message': f"Cannot check temp directory: {e}"
                    })
        
        return issues
    
    def calculate_security_score(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate overall security score."""
        total_issues = scan_results.get('total_issues', 0)
        files_scanned = scan_results.get('files_scanned', 1)
        
        # Count issues by severity
        high_issues = 0
        medium_issues = 0
        low_issues = 0
        
        for file_result in scan_results.get('file_results', []):
            for issue in file_result.get('issues', []):
                severity = issue.get('severity', 'LOW')
                if severity == 'HIGH':
                    high_issues += 1
                elif severity == 'MEDIUM':
                    medium_issues += 1
                else:
                    low_issues += 1
        
        # Calculate weighted score (0-100)
        penalty = (high_issues * 20) + (medium_issues * 5) + (low_issues * 1)
        max_penalty = files_scanned * 25  # Assume max 25 points penalty per file
        
        if max_penalty > 0:
            score = max(0, 100 - (penalty / max_penalty * 100))
        else:
            score = 100
        
        # Determine security grade
        if score >= 90:
            grade = 'A'
        elif score >= 80:
            grade = 'B'
        elif score >= 70:
            grade = 'C'
        elif score >= 60:
            grade = 'D'
        else:
            grade = 'F'
        
        return {
            'score': round(score, 1),
            'grade': grade,
            'total_issues': total_issues,
            'high_severity': high_issues,
            'medium_severity': medium_issues,
            'low_severity': low_issues,
            'files_scanned': files_scanned
        }
    
    def _get_severity(self, category: str) -> str:
        """Get severity level for vulnerability category."""
        severity_map = {
            'timing_attacks': 'HIGH',
            'side_channel': 'HIGH', 
            'resource_exhaustion': 'MEDIUM',
            'injection_vectors': 'HIGH',
            'crypto_weaknesses': 'HIGH'
        }
        return severity_map.get(category, 'LOW')
    
    def _get_vulnerability_message(self, category: str) -> str:
        """Get human-readable message for vulnerability category."""
        messages = {
            'timing_attacks': 'Potential timing attack vulnerability',
            'side_channel': 'Possible side-channel information leakage',
            'resource_exhaustion': 'Resource exhaustion vulnerability',
            'injection_vectors': 'Potential injection attack vector',
            'crypto_weaknesses': 'Cryptographic weakness detected'
        }
        return messages.get(category, 'Security issue detected')
    
    def _calculate_risk_level(self, issues: List[Dict[str, Any]]) -> str:
        """Calculate overall risk level for file."""
        if not issues:
            return 'LOW'
        
        high_count = sum(1 for issue in issues if issue.get('severity') == 'HIGH')
        medium_count = sum(1 for issue in issues if issue.get('severity') == 'MEDIUM')
        
        if high_count > 0:
            return 'HIGH'
        elif medium_count > 2:
            return 'HIGH'
        elif medium_count > 0:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def _generate_recommendations(self, issues: List[Dict[str, Any]]) -> List[str]:
        """Generate security recommendations based on issues."""
        recommendations = []
        
        categories = set(issue.get('type') for issue in issues)
        
        if 'timing_attacks' in categories:
            recommendations.append("Use synchronous design patterns to prevent timing attacks")
        
        if 'side_channel' in categories:
            recommendations.append("Implement constant-time algorithms for sensitive operations")
        
        if 'resource_exhaustion' in categories:
            recommendations.append("Add bounds checking and resource limits")
        
        if 'injection_vectors' in categories:
            recommendations.append("Remove debug outputs and system calls from production code")
        
        if 'crypto_weaknesses' in categories:
            recommendations.append("Use cryptographically secure random number generators")
        
        return recommendations
    
    def _generate_scan_summary(self, file_results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate summary of scan results."""
        summary = {
            'vulnerability_categories': {},
            'severity_distribution': {'HIGH': 0, 'MEDIUM': 0, 'LOW': 0},
            'most_vulnerable_files': [],
            'common_issues': []
        }
        
        # Count by category and severity
        for file_result in file_results:
            for issue in file_result.get('issues', []):
                category = issue.get('type', 'unknown')
                severity = issue.get('severity', 'LOW')
                
                summary['vulnerability_categories'][category] = \
                    summary['vulnerability_categories'].get(category, 0) + 1
                summary['severity_distribution'][severity] += 1
        
        # Find most vulnerable files
        file_scores = [(fr['file'], len(fr['issues'])) for fr in file_results]
        summary['most_vulnerable_files'] = sorted(file_scores, 
                                                  key=lambda x: x[1], 
                                                  reverse=True)[:5]
        
        # Find common issues
        category_counts = summary['vulnerability_categories']
        summary['common_issues'] = sorted(category_counts.items(),
                                          key=lambda x: x[1], 
                                          reverse=True)[:3]
        
        return summary